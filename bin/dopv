#!/usr/bin/env ruby

#
# DOPv command line client
#

require 'optparse'
require 'dopv'
require 'pry-debugger'

ERROR = {
  :parse_error    => 1,
  :plan_error     => 2,
  :provider_error => 4,
  :unknown_error  => -1
}

options = {}

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: dopv [options]'
  opts.on('-p', '--plan FILE', String, 'Specify a plan file to execute') { |file| options[:plan] = file }
  opts.on('-d', '--disk-db FILE', String, 'Specify disk state file') { |file| options[:disk_db] = file }
  opts.on('-t', '--trace', 'Show back traces on errors') { |trace| options[:trace] = true }
  opts.on('-h', '--help', String, 'Display help') do
    puts opts
    exit
  end
end

ARGV << "-h" if ARGV.empty?
error_msg = error_bt = error_code = nil
begin
 parser.parse!

 plan = Dopv::Plan.load(options[:plan], options[:disk_db])
 plan.execute
rescue OptionParser::ParseError => e
  error_msg   = e
  error_bt    = e.backtrace.join("\n")
  error_code  = ERROR[:parse_error]
rescue Dopv::Errors::PlanError => e
  error_msg   = e
  error_bt    = e.backtrace.join("\n")
  error_code  = ERROR[:plan_error]
rescue Dopv::Errors::ProviderError => e
  error_msg   = e
  error_bt    = e.backtrace.join("\n")
  error_code  =  ERROR[:provider_error]
rescue Exception => e
  error_msg   = e
  error_bt    = e.backtrace.join("\n")
  error_code  =  ERROR[:unknown_error]
end

Dopv::log.fatal { error_msg.message } if error_msg
STDERR.puts "\n#{error_bt}" if (options[:trace] && error_bt)
exit error_code if error_code
