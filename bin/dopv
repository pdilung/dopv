#!/usr/bin/env ruby

#
# DOPv command line client
#

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])

require 'optparse'
require 'dopv'

PROGNAME = 'dopv'

ERROR_CODES = {
  :parse_error    => 1,
  :plan_error     => 2,
  :provider_error => 4,
  :unknown_error  => -1
}

ERROR_SOURCES = {
  :parse_error    => 'parser',
  :plan_error     => 'plan',
  :provider_error => 'provider',
  :unknown_error  => 'unknown'
}

LOG_LEVELS = {
  :debug  => Logger::DEBUG,
  :info   => Logger::INFO,
  :warn   => Logger::WARN,
  :error  => Logger::ERROR,
  :fatal  => Logger::FATAL
}

options = {
  :logfile  => STDOUT,
  :loglevel => LOG_LEVELS[:info]
}
error_code = 0

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: dopv [options]'
  opts.on("-p", "--plan FILE",
          "Specify a plan file to execute") {|file| options[:plan] = file}
  opts.on("-d", "--disk-db FILE",
          "Specify disk state file") {|file| options[:disk_db] = file}
  opts.on("-l", "--log-file FILE",
          "Specify log file (by default standard output)") do |file|
    options[:logfile] = file if file
  end
  opts.on("-v", "--log-level LEVEL",
          "Specify a minimal log level to log",
          "(can be one of debug, info - the default, warning, error)") do |level|
            options[:loglevel] = LOG_LEVELS[level.to_sym]  if level
  end
  opts.on("-t", "--trace",
          "Show back traces on errors") {|trace| options[:trace] = true}
  opts.on("-h", "--help", "Display help") do
    puts opts
    exit
  end
end

ARGV << "-h" if ARGV.empty?

begin
 parser.parse!

 Dopv.log(options[:logfile])
 Dopv.log.progname = PROGNAME
 Dopv.log.level = options[:loglevel]

 plan = Dopv::Plan.load(options[:plan], options[:disk_db])
 plan.execute

rescue OptionParser::ParseError => e
  error_code = ERROR_CODES[:parse_error]
rescue Dopv::Errors::PlanError => e
  error_code = ERROR_CODES[:plan_error]
rescue Dopv::Errors::ProviderError => e
  error_code =  ERROR_CODES[:provider_error]
rescue SystemExit
  nil
rescue Exception => e
  binding.pry
  error_code =  ERROR_CODES[:unknown_error]
end

if error_code != 0
  Dopv::log.fatal {"%s: %s." % [ERROR_SOURCES[ERROR_CODES.key(error_code)].capitalize, e.message.gsub(/\.*$/, '')] }
  STDERR.puts "\n#{e.backtrace.join("\n")}" if options[:trace]
end
  
exit error_code
