#!/usr/bin/env ruby

#
# DOPv command line client
#

require 'optparse'
require 'dopv'

ERROR_CODES = {
  :parse_error    => 1,
  :plan_error     => 2,
  :provider_error => 4,
  :unknown_error  => -1
}

ERROR_SOURCES = {
  :parse_error    => 'parser',
  :plan_error     => 'plan',
  :provider_error => 'provider',
  :unknown_error  => 'unknown'
}

options = {}
error_code = 0

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: dopv [options]'
  opts.on('-p', '--plan FILE', String, 'Specify a plan file to execute') { |file| options[:plan] = file }
  opts.on('-d', '--disk-db FILE', String, 'Specify disk state file') { |file| options[:disk_db] = file }
  opts.on('-t', '--trace', 'Show back traces on errors') { |trace| options[:trace] = true }
  opts.on('-h', '--help', String, 'Display help') do
    puts opts
    exit
  end
end

ARGV << "-h" if ARGV.empty?

begin
 parser.parse!

 plan = Dopv::Plan.load(options[:plan], options[:disk_db])
 plan.execute
rescue OptionParser::ParseError => e
  error_code = ERROR_CODES[:parse_error]
rescue Dopv::Errors::PlanError => e
  error_code = ERROR_CODES[:plan_error]
rescue Dopv::Errors::ProviderError => e
  error_code =  ERROR_CODES[:provider_error]
rescue Exception => e
  error_code =  ERROR_CODES[:unknown_error]
end

if error_code != 0
  Dopv::log.fatal {"%s: %s." % [ERROR_SOURCES[ERROR_CODES.key(error_code)].capitalize, e.message.gsub(/\.*$/, '')] }
  STDERR.puts "\n#{e.backtrace.join("\n")}" if options[:trace]
end
  
exit error_code
